# Phase2 DB マイグレーション運用

## 目的
- ローカル/CI/本番で同じルールと同じコマンドを使い、DB 変更を再現可能かつ監査可能に運用する。

## 最終決定
- 採用ツール: `psql` + 運用スクリプト
  - `scripts/verify_migration_files.sh`（命名/順序検証）
  - `scripts/apply_db_migrations.sh`（適用本体）
- 単一の真実: `backend/db/migrations/*.sql`
- 命名規約: `YYYYMMDDHHMMSS_description.sql`

## 1. ローカル運用

### 手順
1. アプリDB起動と初期適用
```bash
make db-setup
```

2. 追加マイグレーション作成後の検証
```bash
./scripts/verify_migration_files.sh
```

3. 既存DBに追加適用
```bash
set -a
source backend/.env
set +a
./scripts/apply_db_migrations.sh
```

### 運用ルール
- マイグレーションは必ずタイムスタンプ昇順で追加する（過去番号への差し込み禁止）。
- 既に適用済みの SQL ファイルは書き換えない。
- 破壊的変更は expand/contract で段階的に行う（同時にアプリを壊さない）。

## 2. CI 運用

### ワークフロー
- ファイル: `.github/workflows/migration-validation.yml`
- 実施内容:
1. 命名/順序検証（`verify_migration_files.sh`）
2. クリーンDBを起動して全マイグレーション適用（`apply_db_migrations.sh`）

### 目的
- PR 段階で「規約違反」「適用失敗」を検知し、本番事故を未然に防ぐ。

## 3. 本番運用（Neon / Fly.io 前提）

### 事前準備
1. リリース対象コミットを確定する。
2. Neon 側でバックアップ/復元ポイントを確保する。
3. 適用ウィンドウ（実施時刻・担当者）を決める。

### 適用手順
1. 本番 `DATABASE_URL` を設定する。
2. 規約検証を実行する。
```bash
./scripts/verify_migration_files.sh
```
3. 本番適用を実行する。
```bash
./scripts/apply_db_migrations.sh
```
4. アプリの主要機能（ログイン、作問、クイズ、マイページ）をスモーク確認する。

## 4. ロールバック方針
- 原則: down migration ではなく forward fix（追加マイグレーションで修復）を優先する。
- 緊急時: Neon の復元ポイントから DB を切り戻し、アプリ接続先を復元先へ戻す。
- 事故防止:
  - 破壊的DDLは単発で行わず、段階リリース（expand/contract）を徹底する。
  - 重大変更前は必ずステージング相当環境で同手順をリハーサルする。

### 4.1 採用理由（詳細）
1. `down migration` はデータを完全復元できるとは限らないため
- カラム削除、型変換、データ再計算を伴う変更では、`down` を書いても元データの意味まで戻せないケースがある。

2. 履歴/統計データの保全を優先するため
- 本プロジェクトは解答履歴や正答率を扱うため、巻き戻し時のデータ欠損リスクを最小化する必要がある。
- `forward fix` は既存データを残したまま整合性を回復しやすい。

3. 障害時の運用判断を単純化するため
- インシデント中に「どの `down` をどこまで適用するか」を判断するのは難易度が高い。
- 原則を `forward fix` に固定することで、初動時の判断分岐を減らせる。

4. 環境間の再現性を維持するため
- ローカル/CI/本番で同一スクリプト（`apply_db_migrations.sh`）を使う方針と整合する。
- `down` 常用運用を前提にすると、検証観点と手順が増え、運用差分が大きくなる。

5. 緊急時の切り戻しは DB 基盤機能のほうが現実的なため
- 致命的なデータ汚染や広範囲障害では、個別 `down` より Neon の復元ポイントのほうが確実な場合がある。
- そのため通常時は `forward fix`、最悪時は基盤復元の二段構えを採用する。

### 4.2 forward fix 適用例
1. 制約追加で既存データが違反して適用失敗した場合
- 先に補正用マイグレーションを追加し、違反データを修正してから制約追加マイグレーションを再適用する。

2. カラム型変更後に一部機能で想定外フォーマットが発生した場合
- 旧フォーマット互換の補助カラム/変換処理を追加するマイグレーションを投入し、段階的にデータ移行する。

3. インデックス設計不備で性能劣化が起きた場合
- 問題のインデックスを即時削除せず、必要な新規インデックスを追加して切り替え後に不要分を削除する。

4. nullable/non-null 制約の変更でアプリ互換が崩れた場合
- 一時的に nullable へ戻す追加マイグレーションを適用し、アプリ修正後に再度 non-null 化する。

5. 誤ったデフォルト値で新規データが汚染された場合
- デフォルト値修正マイグレーションと、影響期間データを補正するデータ修復マイグレーションを追加する。

### 4.3 適用判断の目安
1. 軽微な不整合（局所的なDDL/データ修正で回復可能）: `forward fix`
2. 広範囲なデータ破損（短時間で安全に修復不能）: Neon 復元ポイントから切り戻し
3. 判断が難しい場合: 先に書き込みを止めて影響範囲を固定し、復旧手段を決定する

## 5. チェックリスト
- [ ] 命名規約を満たしている
- [ ] CI の migration-validation が成功している
- [ ] 本番適用前に Neon バックアップを確保した
- [ ] 適用後のスモークテスト結果を記録した
